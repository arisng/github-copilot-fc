---
date: 2026-02-15
type: feedback
severity: medium
status: resolved
tags:
  - ralph-v2
  - workflow
---

# Feedbacks for Ralph v2.2.0

## Enhancements for Skills Enforcement in Ralph v2 Workflow

- should not restrict max skills per invocation for now, instead enhance the current Skills Discovery and Activation step by including a reasoning process to match relevant skills to the current task, and load them via terminal for the subagent to use
- considering remove pre-list discovered skills in session instructions template to avoid duplicate effort of skills discovery and activation, in the end the subagent will still need to do the skills discovery and activation by itself, so we can just let the subagent do the discovery and activation without pre-listing the discovered skills in the session instructions template, as long as we ensure that the subagent can discover and activate the relevant skills successfully, then it should be fine. This is to avoid confusion and potential inconsistency between the pre-listed skills in the session instructions template and the actual discovered and activated skills in the subagent's workflow. We want to make sure that the subagent has full control and responsibility over its own skills discovery and activation process, and we do not want to create any unnecessary dependencies or assumptions based on the pre-listed skills in the session instructions template.
- the delegation of skills discovery and activation to the subagents might introduce repetition of similar steps across related tasks in a plan, but it might also help discover new skills at runtime where these skills are not known upfront during the planning phase if we rely on the planner to do the skills discovery and activation. For example, if we have a task that requires a specific skill that is not known during the planning phase, but it can be discovered and activated at runtime by the subagent when it is executing the task, then it can be beneficial to delegate the skills discovery and activation to the subagent. This allows for more flexibility and adaptability in the workflow, as the subagent can discover and activate new skills as needed based on the specific requirements of each task, rather than being limited to a predefined set of skills that were discovered during the planning phase. However, we need to ensure that the subagents have a robust and efficient mechanism for discovering and activating skills at runtime, so that it does not introduce significant overhead or delays in the execution of tasks.
- a subagent might has been instructed to use specific skills in its own "custom agent" instructions, or specific skills might be mentioned explicitly in the task description or message sent from the orchestrator, these can be indicators to the subagent that these skills must be prioritized during the skills discovery and activation process. For example, if an subagent's instructions explicitly mention that it should use the `git-atomic-commit` skill for executing atomic commits after reviewing a task, then the subagent should prioritize discovering and activating the `git-atomic-commit` skill during its skills discovery and activation step, as this is a clear requirement for the successful execution of its tasks. Similarly, if the orchestrator sends a message to the subagent that includes specific instructions to use certain skills for a task, then the subagent should also prioritize discovering and activating those skills, as they are directly relevant to the task at hand. This way, we can ensure that the subagents are effectively utilizing the relevant skills that are necessary for their tasks, while still allowing them the flexibility to discover and activate additional skills as needed based on their own reasoning process and the specific requirements of each task.

## Git Atomic Commit should be executed in a separate mode

- For the Reviewer subagent, the execution of git atomic commits should be handled in a separate mode (e.g. COMMIT Mode) that is triggered after the review of a task is passed, this COMMIT Mode can be responsible for executing the git atomic commit for the task using the `git-atomic-commit` skill, and it can also handle any necessary cleanup or post-commit actions after the commit is executed. This way, we can ensure that the execution of git atomic commits is properly integrated into the workflow without introducing unnecessary complexity or overhead in the main execution flow of tasks. It also allows us to have a clear separation of concerns, where the main execution flow focuses on executing tasks and generating outputs, while the COMMIT Mode focuses on handling the specific requirements and actions related to executing git atomic commits.
- Also, it's very important that the Reviewer subagent must only commit relevant changes related to the specific task that is being reviewed and passed, and it should not commit any unrelated changes that might be present in the working directory. More importantly, changes that should be committed might be parts of a file that has other unrelated changes, so the Reviewer subagent should be able to stage only the relevant changes for the specific task, and then execute the git atomic commit for those staged changes, this is to ensure that we maintain a clean and organized commit history that accurately reflects the work done for each specific task, without including any unrelated changes that might cause confusion or make it harder to track the history of changes in the repository.
- Also taking this chance to ensure the review.md file in each iteration has a consistent, solid, and structured template for the review notes, this would ensure readability and clarity for the "human watchers" and also ensure that the Reviewer subagent can reliably parse and utilize the information in the review.md for its next iterations, and especially for the COMMIT Mode where it needs to determine which changes are relevant for the git atomic commit based on the review notes.

## Refining the Knowledge Carryover and Approval Across Iterations

- I'm thinking of bringing the knowledge folder in iteration-scope to session-scope, and the knowledge approval process will be designed in a way that the knowledge can be approved in one iteration, but it can be carried over and used in subsequent iterations without needing to be re-approved, this is to ensure that the knowledge that has been approved can be reused across iterations without unnecessary overhead of re-approval, while still maintaining a clear and efficient approval process for new knowledge that is generated in each iteration. For example, if we have a piece of knowledge that is generated and approved in iteration 1, then it can be stored in the session-scope knowledge folder and can be accessed and used by subsequent iterations (e.g. iteration 2, iteration 3, etc.) without needing to go through the approval process again, as long as it is still relevant and applicable to the tasks in those subsequent iterations. This way, we can ensure that we are effectively leveraging the approved knowledge across iterations while still maintaining a streamlined approval process for new knowledge.
- This way would help streamline the process of accumulating and reusing knowledge across iterations, as the approved knowledge can be easily accessed and utilized by subsequent iterations without needing to go through the approval process again, while still ensuring that any new knowledge generated in each iteration goes through the necessary approval process to maintain the quality and relevance of the knowledge being used in the workflow.

## Critique the current task dependencies and task breakdown process in the Planner subagent

- I want to ensure the task dependency is thoroughly analyzed and properly reflected in the task breakdown process in the Planner subagent, as this is crucial for the successful execution of waves of tasks in each iteration. This might require enhancing the Planner subagent's reasoning process to better analyze tasks and their dependencies, and to generate a more accurate and effective task breakdown that takes into account the dependencies between tasks. For example, if we have a task that has certain dependencies on other tasks, the Planner subagent should be able to identify those dependencies and ensure that the task breakdown process reflects those dependencies in a way that allows for the proper sequencing and execution of tasks in each wave. This way, we can help ensure that the workflow runs smoothly and efficiently, with tasks being executed in the correct order based on their dependencies, which can ultimately lead to better outcomes and results from the workflow.
- I mention this here not because of the current task breakdown in the current iteration is not good enough, but I want to make sure that we have a clear focus on this aspect and continuously improve it in future iterations, as the complexity of tasks and their dependencies can increase significantly as we tackle more complex problems, and having a robust task breakdown process that effectively handles dependencies will be crucial for the success of the workflow in those scenarios.
- Ensure tasks are grouped in waves and waves are clearly documented in the plan.md, this can help provide better visibility and clarity on the execution flow of tasks in each iteration, and it can also help with the coordination and management of tasks across different agents and subagents involved in the workflow.
- Also taking this chance to ensure plan.md has a consistent, solid and structured template in each iteration. This would ensure readability and clarity for the "human watchers" and also ensure that the agents can reliably parse and utilize the information in the plan.md for their execution.